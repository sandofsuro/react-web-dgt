/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
'use strict';

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var assert = require('assert');
var fs = require('fs');
var path = require('./fastpath');
var Activity = require('./Activity');
var Cache = require('./Cache');
var DependencyGraph = require('./DependencyGraph');
var Polyfill = require('./Polyfill');

var Resolver = (function () {
  function Resolver(_ref) {
    var roots = _ref.roots;
    var blacklistRE = _ref.blacklistRE;
    var _ref$providesModuleNodeModules = _ref.providesModuleNodeModules;
    var providesModuleNodeModules = _ref$providesModuleNodeModules === undefined ? [] : _ref$providesModuleNodeModules;
    var _ref$polyfillModuleNames = _ref.polyfillModuleNames;
    var polyfillModuleNames = _ref$polyfillModuleNames === undefined ? [] : _ref$polyfillModuleNames;
    var platforms = _ref.platforms;
    var _ref$preferNativePlatform = _ref.preferNativePlatform;
    var preferNativePlatform = _ref$preferNativePlatform === undefined ? true : _ref$preferNativePlatform;
    var assetExts = _ref.assetExts;
    var fileWatcher = _ref.fileWatcher;
    var resetCache = _ref.resetCache;
    var shouldThrowOnUnresolvedErrors = _ref.shouldThrowOnUnresolvedErrors;

    _classCallCheck(this, Resolver);

    roots = roots.map(function (root) {
      return path.resolve(root);
    });

    roots.forEach(verifyRootExists);

    this._depGraph = new DependencyGraph({
      activity: Activity,
      roots: roots,
      assetExts: assetExts,
      providesModuleNodeModules: providesModuleNodeModules,
      platforms: platforms || ['ios', 'android', 'web', 'weex'],
      preferNativePlatform: preferNativePlatform,
      fileWatcher: fileWatcher,
      shouldThrowOnUnresolvedErrors: shouldThrowOnUnresolvedErrors,
      ignoreFilePath: function ignoreFilePath(filepath) {
        return filepath.indexOf('__tests__') !== -1 || blacklistRE && blacklistRE.test(filepath);
      },
      cache: new Cache({
        resetCache: resetCache,
        cacheKey: ['haste-resolver-cache', roots.join(',').split(path.sep).join('-')].join('$')
      })
    });

    this._polyfillModuleNames = polyfillModuleNames || [];

    this._depGraph.load()['catch'](function (err) {
      console.error(err.message + '\n' + err.stack);
      process.exit(1);
    });
  }

  _createClass(Resolver, [{
    key: 'getDependencies',
    value: function getDependencies(main, options) {
      var _this = this;

      return this._depGraph.getDependencies({
        entryPath: main,
        platform: options.platform,
        recursive: options.recursive
      }).then(function (resolutionResponse) {
        _this._getPolyfillDependencies().reverse().forEach(function (polyfill) {
          return resolutionResponse.prependDependency(polyfill);
        });

        return resolutionResponse.finalize();
      });
    }
  }, {
    key: '_getPolyfillDependencies',
    value: function _getPolyfillDependencies() {
      var polyfillModuleNames = this._polyfillModuleNames;

      return polyfillModuleNames.map(function (polyfillModuleName, idx) {
        return new Polyfill({
          path: polyfillModuleName,
          id: polyfillModuleName,
          dependencies: polyfillModuleNames.slice(0, idx),
          isPolyfill: true
        });
      });
    }
  }, {
    key: 'getHasteMap',
    value: function getHasteMap() {
      var depGraph = this._depGraph;
      return depGraph.load().then(function () {
        return depGraph._hasteMap;
      });
    }
  }, {
    key: 'resolveRequires',
    value: function resolveRequires(resolutionResponse, module, code) {
      return Promise.resolve().then(function () {
        if (module.isPolyfill()) {
          return Promise.resolve({ code: code });
        }

        var resolvedDeps = Object.create(null);
        var resolvedDepsArr = [];

        return Promise.all(resolutionResponse.getResolvedDependencyPairs(module).map(function (_ref2) {
          var _ref22 = _slicedToArray(_ref2, 2);

          var depName = _ref22[0];
          var depModule = _ref22[1];

          if (depModule) {
            return depModule.getName().then(function (name) {
              resolvedDeps[depName] = name;
              resolvedDepsArr.push(name);
            });
          }
        })).then(function () {
          var relativizeCode = function relativizeCode(codeMatch, pre, quot, depName, post) {
            var depId = resolvedDeps[depName];
            if (depId) {
              return pre + quot + depId + post;
            } else {
              return codeMatch;
            }
          };

          code = code.replace(replacePatterns.IMPORT_RE, relativizeCode).replace(replacePatterns.EXPORT_RE, relativizeCode).replace(replacePatterns.REQUIRE_RE, relativizeCode);

          return module.getName().then(function (name) {
            return { name: name, code: code };
          });
        });
      });
    }
  }, {
    key: 'wrapModule',
    value: function wrapModule(resolutionResponse, module, code) {
      if (module.isPolyfill()) {
        return Promise.resolve({
          code: definePolyfillCode(code)
        });
      }

      return this.resolveRequires(resolutionResponse, module, code).then(function (_ref3) {
        var name = _ref3.name;
        var code = _ref3.code;

        return { name: name, code: defineModuleCode(name, code) };
      });
    }
  }]);

  return Resolver;
})();

function defineModuleCode(moduleName, code) {
  return ['__d(', '\'' + moduleName + '\',', 'function(global, require, module, exports) {', '  ' + code, '\n});'].join('');
}

function definePolyfillCode(code) {
  return ['(function(global) {', code, '\n})(typeof global !== \'undefined\' ? global : typeof self !== \'undefined\' ? self : this);'].join('');
}

function verifyRootExists(root) {
  // Verify that the root exists.
  assert(fs.statSync(root).isDirectory(), 'Root has to be a valid directory');
}

module.exports = Resolver;